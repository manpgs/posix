<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   et
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PTHREAD_SIGMASK(3P)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PTHREAD_SIGMASK(3P)</td>
    <td class="head-vol">POSIX Programmer's Manual</td>
    <td class="head-rtitle">PTHREAD_SIGMASK(3P)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="PROLOG"><a class="permalink" href="#PROLOG">PROLOG</a></h1>
<p class="Pp">This manual page is part of the POSIX Programmer's Manual. The
    Linux implementation of this interface may differ (consult the corresponding
    Linux manual page for details of Linux behavior), or the interface may not
    be implemented on Linux.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">pthread_sigmask, sigprocmask &#x2014; examine and change blocked
    signals</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>#include &lt;signal.h&gt;</pre>
<pre>int pthread_sigmask(int <i>how</i>, const sigset_t *restrict <i>set</i>,
    sigset_t *restrict <i>oset</i>);
int sigprocmask(int <i>how</i>, const sigset_t *restrict <i>set</i>,
    sigset_t *restrict <i>oset</i>);</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <i>pthread_sigmask</i>() function shall examine or change (or
    both) the calling thread's signal mask, regardless of the number of threads
    in the process. The function shall be equivalent to <i>sigprocmask</i>(),
    without the restriction that the call be made in a single-threaded
  process.</p>
<p class="Pp">In a single-threaded process, the <i>sigprocmask</i>() function
    shall examine or change (or both) the signal mask of the calling thread.</p>
<p class="Pp">If the argument <i>set</i> is not a null pointer, it points to a
    set of signals to be used to change the currently blocked set.</p>
<p class="Pp">The argument <i>how</i> indicates the way in which the set is
    changed, and the application shall ensure it consists of one of the
    following values:</p>
<dl class="Bl-tag">
  <dt id="SIG_BLOCK"><a class="permalink" href="#SIG_BLOCK">SIG_BLOCK</a></dt>
  <dd>The resulting set shall be the union of the current set and the signal set
      pointed to by <i>set</i>.</dd>
  <dt id="SIG_SETMASK"><a class="permalink" href="#SIG_SETMASK">SIG_SETMASK</a></dt>
  <dd>The resulting set shall be the signal set pointed to by <i>set</i>.</dd>
  <dt id="SIG_UNBLOCK"><a class="permalink" href="#SIG_UNBLOCK">SIG_UNBLOCK</a></dt>
  <dd>The resulting set shall be the intersection of the current set and the
      complement of the signal set pointed to by <i>set</i>.</dd>
</dl>
<p class="Pp">If the argument <i>oset</i> is not a null pointer, the previous
    mask shall be stored in the location pointed to by <i>oset</i>. If
    <i>set</i> is a null pointer, the value of the argument <i>how</i> is not
    significant and the thread's signal mask shall be unchanged; thus the call
    can be used to enquire about currently blocked signals.</p>
<p class="Pp">If there are any pending unblocked signals after the call to
    <i>sigprocmask</i>(), at least one of those signals shall be delivered
    before the call to <i>sigprocmask</i>() returns.</p>
<p class="Pp">It is not possible to block those signals which cannot be ignored.
    This shall be enforced by the system without causing an error to be
    indicated.</p>
<p class="Pp">If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are
    generated while they are blocked, the result is undefined, unless the signal
    was generated by the action of another process, or by one of the functions
    <i>kill</i>(), <i>pthread_kill</i>(), <i>raise</i>(), or
  <i>sigqueue</i>().</p>
<p class="Pp">If <i>sigprocmask</i>() fails, the thread's signal mask shall not
    be changed.</p>
<p class="Pp">The use of the <i>sigprocmask</i>() function is unspecified in a
    multi-threaded process.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">Upon successful completion <i>pthread_sigmask</i>() shall return
    0; otherwise, it shall return the corresponding error number.</p>
<p class="Pp">Upon successful completion, <i>sigprocmask</i>() shall return 0;
    otherwise, -1 shall be returned, <i>errno</i> shall be set to indicate the
    error, and the signal mask of the process shall be unchanged.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp">The <i>pthread_sigmask</i>() and <i>sigprocmask</i>() functions
    shall fail if:</p>
<dl class="Bl-tag">
  <dt id="EINVAL"><a class="permalink" href="#EINVAL"><b>EINVAL</b></a></dt>
  <dd>The value of the <i>how</i> argument is not equal to one of the defined
      values.</dd>
</dl>
<p class="Pp">The <i>pthread_sigmask</i>() function shall not return an error
    code of <b>[EINTR]</b>.</p>
<p class="Pp"><i>The following sections are informative.</i></p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Signaling_in_a_Multi-Threaded_Process"><a class="permalink" href="#Signaling_in_a_Multi-Threaded_Process">Signaling
  in a Multi-Threaded Process</a></h2>
<p class="Pp">This example shows the use of <i>pthread_sigmask</i>() in order to
    deal with signals in a multi-threaded process. It provides a fairly general
    framework that could be easily adapted/extended.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
...</pre>
<pre>static sigset_t   signal_mask;  /* signals to block         */</pre>
<pre>int main (int argc, char *argv[])
{
    pthread_t  sig_thr_id;      /* signal handler thread ID */
    int        rc;              /* return code              */</pre>
<pre>
    sigemptyset (&amp;signal_mask);
    sigaddset (&amp;signal_mask, SIGINT);
    sigaddset (&amp;signal_mask, SIGTERM);
    rc = pthread_sigmask (SIG_BLOCK, &amp;signal_mask, NULL);
    if (rc != 0) {
        /* handle error */
        ...
    }
    /* any newly created threads inherit the signal mask */</pre>
<pre>
    rc = pthread_create (&amp;sig_thr_id, NULL, signal_thread, NULL);
    if (rc != 0) {
        /* handle error */
        ...
    }</pre>
<pre>
    /* APPLICATION CODE */
    ...
}</pre>
<pre>void *signal_thread (void *arg)
{
    int       sig_caught;    /* signal caught       */
    int       rc;            /* returned code       */</pre>
<pre>
    rc = sigwait (&amp;signal_mask, &amp;sig_caught);
    if (rc != 0) {
        /* handle error */
    }
    switch (sig_caught)
    {
    case SIGINT:     /* process SIGINT  */
        ...
        break;
    case SIGTERM:    /* process SIGTERM */
        ...
        break;
    default:         /* should normally not happen */
        fprintf (stderr, &quot;\nUnexpected signal %d\n&quot;, sig_caught);
        break;
    }
}</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="APPLICATION_USAGE"><a class="permalink" href="#APPLICATION_USAGE">APPLICATION
  USAGE</a></h1>
<p class="Pp">None.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RATIONALE"><a class="permalink" href="#RATIONALE">RATIONALE</a></h1>
<p class="Pp">When a thread's signal mask is changed in a signal-catching
    function that is installed by <i>sigaction</i>(), the restoration of the
    signal mask on return from the signal-catching function overrides that
    change (see <i>sigaction</i>()). If the signal-catching function was
    installed with <i>signal</i>(), it is unspecified whether this occurs.</p>
<p class="Pp">See <i>kill</i>() for a discussion of the requirement on delivery
    of signals.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUTURE_DIRECTIONS"><a class="permalink" href="#FUTURE_DIRECTIONS">FUTURE
  DIRECTIONS</a></h1>
<p class="Pp">None.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><i><i>exec</i></i>, <i><i>kill</i>()</i>,
    <i><i>sigaction</i>()</i>, <i><i>sigaddset</i>()</i>,
    <i><i>sigdelset</i>()</i>, <i><i>sigemptyset</i>()</i>,
    <i><i>sigfillset</i>()</i>, <i><i>sigismember</i>()</i>,
    <i><i>sigpending</i>()</i>, <i><i>sigqueue</i>()</i>,
    <i><i>sigsuspend</i>()</i></p>
<p class="Pp">The Base Definitions volume of POSIX.1&#x2010;2017,
    <i><b>&lt;signal.h&gt;</b></i></p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Portions of this text are reprinted and reproduced in electronic
    form from IEEE Std 1003.1-2017, Standard for Information Technology --
    Portable Operating System Interface (POSIX), The Open Group Base
    Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of
    Electrical and Electronics Engineers, Inc and The Open Group. In the event
    of any discrepancy between this version and the original IEEE and The Open
    Group Standard, the original IEEE and The Open Group Standard is the referee
    document. The original Standard can be obtained online at
    http://www.opengroup.org/unix/online.html .</p>
<p class="Pp">Any typographical or formatting errors that appear in this page
    are most likely to have been introduced during the conversion of the source
    files to man page format. To report such errors, see
    https://www.kernel.org/doc/man-pages/reporting_bugs.html .</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017</td>
    <td class="foot-os">IEEE/The Open Group</td>
  </tr>
</table>
</body>
</html>
